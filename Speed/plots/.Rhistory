hist(sd)
Plot1=function(N=1000,seed=0){
#par(mfrow=c(2,1))
if(seed>0) set.seed(seed)
y=rnorm(N)
lambda=0.94
sigma=vector(length=N)
sigma[1]=1
for(i in 2:N){
sigma[i]=lambda* sigma[i-1] + (1-lambda)*y[i-1]^2
y[i]=y[i]*sqrt(sigma[i])
}
# plot(y, main="", xlab="", ylab="", bty="n", col=2, las=1,type="l",bty="l")
# plot(sigma, main=“”, xlab=“”, ylab=“”, bty=“n”, col=“#377EB8”, las=1,type=‘l’,bty=‘l’)
return(sd(y))
}
dev.off()
S <- 10000
sd <- rep(NA, S)
for (i in 1:S){
sd[i] <- Plot1(N = 1e4)
}
hist(sd, breaks = 20)
hist(sd, breaks = 20, xlim = c(0,2))
hist(sd, breaks = 100)
hist(sd, breaks = 100, xlim = c(1, 5))
hist(sd, breaks = 100)
hist(sd, breaks = 100, xlim = c(0,5))
hist(sd, breaks = 1000, xlim = c(0,2))
hist(sd, breaks = 10000, xlim = c(0,2))
mean(sd)
sd
Plot1(1000)
Plot1(1000)
Plot1(1000)
a <- Plot1(1000)
a
Plot1=function(N=1000,seed=0){
#par(mfrow=c(2,1))
if(seed>0) set.seed(seed)
y=rnorm(N)
lambda=0.94
sigma=vector(length=N)
sigma[1]=1
for(i in 2:N){
sigma[i]=lambda* sigma[i-1] + (1-lambda)*y[i-1]^2
y[i]=y[i]*sqrt(sigma[i])
}
# plot(y, main="", xlab="", ylab="", bty="n", col=2, las=1,type="l",bty="l")
# plot(sigma, main=“”, xlab=“”, ylab=“”, bty=“n”, col=“#377EB8”, las=1,type=‘l’,bty=‘l’)
return(sigma)
}
Plot1(N = 1000)
Plot1(N = 10000)
Plot1(N = 100000)
Plot1=function(N=1000,seed=0){
#par(mfrow=c(2,1))
if(seed>0) set.seed(seed)
y=rnorm(N)
lambda=0.94
sigma=vector(length=N)
sigma[1]=1
for(i in 2:N){
sigma[i]=lambda* sigma[i-1] + (1-lambda)*y[i-1]^2
y[i]=y[i]*sqrt(sigma[i])
}
# plot(y, main="", xlab="", ylab="", bty="n", col=2, las=1,type="l",bty="l")
# plot(sigma, main=“”, xlab=“”, ylab=“”, bty=“n”, col=“#377EB8”, las=1,type=‘l’,bty=‘l’)
return(y)
}
Plot1(N = 10000)
Plot1=function(N=1000,seed=0){
#par(mfrow=c(2,1))
if(seed>0) set.seed(seed)
y=rnorm(N)
lambda=0.94
sigma=vector(length=N)
sigma[1]=1
for(i in 2:N){
sigma[i]=lambda* sigma[i-1] + (1-lambda)*y[i-1]^2
y[i]=y[i]*sqrt(sigma[i])
}
# plot(y, main="", xlab="", ylab="", bty="n", col=2, las=1,type="l",bty="l")
# plot(sigma, main=“”, xlab=“”, ylab=“”, bty=“n”, col=“#377EB8”, las=1,type=‘l’,bty=‘l’)
return(sigma)
}
Plot1(N = 10000)
plot(Plot1(N = 10000))
Plot1(N = 10000)
Plot1=function(N=1000,seed=0){
#par(mfrow=c(2,1))
if(seed>0) set.seed(seed)
y=rnorm(N)
lambda=0.94
sigma=vector(length=N)
sigma[1]=1
for(i in 2:N){
sigma[i]=lambda* sigma[i-1] + (1-lambda)*y[i-1]^2
y[i]=y[i]*sqrt(sigma[i])
}
plot(y, main="", xlab="", ylab="", bty="n", col=2, las=1,type="l",bty="l")
# plot(sigma, main=“”, xlab=“”, ylab=“”, bty=“n”, col=“#377EB8”, las=1,type=‘l’,bty=‘l’)
return(sigma)
}
Plot1(N = 10000)
Plot1(N = 10000)
Plot1(N = 10000)
Plot1(N = 10000)
Plot1(N = 10000)
Plot1(N = 10000)
Plot1(N = 10000)
Plot1(N = 10000)
Plot1(N = 10000)
Plot1(N = 10000)
x <- seq(0.1, 10, by = 0.1)
y <- numeric()
y[1] <- 2
r <- 0.02
for (i in 2:100){
y[i] <- y[i-1]*(1+r)
}
plot(y)
r <- 0.05
for (i in 2:100){
y[i] <- y[i-1]*(1+r)
}
plot(y)
plot(y, type = "l")
y
for (i in 2:200){
y[i] <- y[i-1]*(1+r)
}
y
for (i in 2:100){
y[i] <- y[i-1]*(1+r)
}
plot(y, type = "l")
# At 100 days, takes 14-15 times to double
y
y <- numeric()
y[1] <- 2
r <- 0.05
for (i in 2:100){
y[i] <- y[i-1]*(1+r)
}
plot(y, type = "l")
# At 100 days, takes 14-15 times to double
y
x <- 1:100
# At 100 days, takes 14-15 times to double
log_y <- log(y)
lm(log_y ~ x)
e^0.04879
exp(0.04879)
log(2)/log(1.05)
y
plot(log_y)
# install.packages("music")
library(music)
# Create system of notes
notes <- c("C", "C#", "D", "Eb", "E", "F", "F#", "G", "G#", "A", "Bb", "B")
allnotes <- character()
for (i in 3:8) {
for (j in 1:length(notes)) {
allnotes = c(allnotes, paste0(notes[j],i))
}
}
# Adding Collatz numbers
collatz_stop <- function(N) {
# Returns steps needed for the series to reach 1
steps = 0
while (N != 1) {
if (N %% 2 == 0) {
N = N/2
} else {
N = 3 * N + 1
}
steps = steps + 1
}
return(steps)
}
collatz <- numeric()
for (i in 2:200) {
collatz[i-1] = collatz_stop(i)
}
plot(collatz)
length(unique(collatz))
keys <- sort(unique(collatz))
# Transform collatz into notes
collatz_notes <- numeric()
for (i in 1:length(collatz)) {
collatz_notes[i] <- allnotes[match(collatz[i], keys)]
}
?rle
rle(c(1,2,3,4))
rle(c(1,2,3,4,1,1,1))
rle(c(1,1,2,2,1,1))
durations <- function(x) {
tmp_seq <- sequence(rle(as.character(x))$lengths)
tmp_new <- numeric()
for (i in 1:length(tmp_seq)) {
if (tmp_seq[i+1] != 1  & i < length(tmp_seq)) {
tmp_new[i] <- NA
} else {
tmp_new[i] <- tmp_seq[i]
}
}
music <- matrix(NA, nrow = length(x), ncol = 2)
music[,1] <- x
music[,2] <- tmp_new
music <- music[which(!is.na(music[,2])),]
return(music)
}
# Get the matrix for Collatz
collatz_music <- durations(collatz_notes)
collatz_music
# Play it!
bpm <- 300
for (i in 1:dim(collatz_music)[1]) {
playNote(collatz_music[i,1], duration = as.integer(collatz_music[i,2]), BPM = bpm)
Sys.sleep(60*as.integer(collatz_music[i,2])/bpm)
}
q()
# install.packages("music")
library(music)
# Create system of notes
notes <- c("C", "C#", "D", "Eb", "E", "F", "F#", "G", "G#", "A", "Bb", "B")
allnotes <- character()
for (i in 3:8) {
for (j in 1:length(notes)) {
allnotes = c(allnotes, paste0(notes[j],i))
}
}
# Adding Collatz numbers
collatz_stop <- function(N) {
# Returns steps needed for the series to reach 1
steps = 0
while (N != 1) {
if (N %% 2 == 0) {
N = N/2
} else {
N = 3 * N + 1
}
steps = steps + 1
}
return(steps)
}
collatz <- numeric()
for (i in 2:200) {
collatz[i-1] = collatz_stop(i)
}
length(unique(collatz))
keys <- sort(unique(collatz))
plot(collatz)
# Code that turns the first 200 integers' Collatz's stopping times into music and plays it
# install.packages("music")
library(music)
# Create system of notes
notes <- c("C", "C#", "D", "Eb", "E", "F", "F#", "G", "G#", "A", "Bb", "B")
allnotes <- character()
for (i in 3:8) {
for (j in 1:length(notes)) {
allnotes = c(allnotes, paste0(notes[j],i))
}
}
# Adding Collatz numbers
collatz_stop <- function(N) {
# Returns steps needed for the series to reach 1
steps = 0
while (N != 1) {
if (N %% 2 == 0) {
N = N/2
} else {
N = 3 * N + 1
}
steps = steps + 1
}
return(steps)
}
collatz <- numeric()
for (i in 2:200) {
collatz[i-1] = collatz_stop(i)
}
length(unique(collatz))
keys <- sort(unique(collatz))
# Transform collatz into notes
collatz_notes <- numeric()
for (i in 1:length(collatz)) {
collatz_notes[i] <- allnotes[match(collatz[i], keys)]
}
# Create durations
durations <- function(x) {
tmp_seq <- sequence(rle(as.character(x))$lengths)
tmp_new <- numeric()
for (i in 1:length(tmp_seq)) {
if (tmp_seq[i+1] != 1  & i < length(tmp_seq)) {
tmp_new[i] <- NA
} else {
tmp_new[i] <- tmp_seq[i]
}
}
music <- matrix(NA, nrow = length(x), ncol = 2)
music[,1] <- x
music[,2] <- tmp_new
music <- music[which(!is.na(music[,2])),]
return(music)
}
# Get the matrix for Collatz
collatz_music <- durations(collatz_notes)
collatz_music
# Play it!
bpm <- 300
for (i in 1:dim(collatz_music)[1]) {
playNote(collatz_music[i,1], duration = as.integer(collatz_music[i,2]), BPM = bpm)
Sys.sleep(60*as.integer(collatz_music[i,2])/bpm)
}
s <- Sys.time()
a <- Sys.time() - s
a
difftime(Sys.time(),s)
difftime(Sys.time(),s, units = "secs")
a <- matrix(c(5,1,3,1,1,1,1,2,1), nrow = 3, ncol = 3, byrow=T)
a
b <- matrix(c(1,2,3), nrow = 1)
a*b
b <- matrix(c(1,2,3), nrow = 3)
a*b
dim(b)
dim(a)
a*b
a%*%b
b <- matrix(c(1,2,3,4,5,6), nrow = 3)
b
b <- matrix(c(1,2,3,4,5,6), nrow = 3, byrow = T)
b
a
a%*%b
setwd("~/SRC/Dropbox/Alvaro/vox_eu/plots")
library(svglite)
library(data.table)
library(RColorBrewer)
co <- brewer.pal(7, "Set1")[2]
co2 <- brewer.pal(7, "Set1")[1]
data <- fread("../speed/x.csv")
R <- data[,list(min(time), mean(time), median(time),
max(time)), keyby = list(language, operation)]
cols <-  c("Min", "Mean", "Median", "Max")
colnames(R)[3:6] <- cols
R <- R[,(cols) := round(.SD,1), .SDcols=cols]
extra_row <- data.frame("Matlab", "read_compressed", NA, NA, NA, NA)
names(extra_row) <- names(R)
R <- rbind(R, extra_row)
R[order(operation, Median)]
compressed <- R[operation == "read_compressed", c("language", "Median")]
compressed$Median <- compressed$Median/min(compressed$Median, na.rm = TRUE)
compressed <- compressed[order(Median)]
uncompressed <- R[operation == "read_uncompressed", c("language", "Median")]
uncompressed$Median <- uncompressed$Median/min(uncompressed$Median, na.rm = TRUE)
uncompressed <- uncompressed[order(Median)]
process <- R[operation == "process", c("language", "Median")]
process$Median <- process$Median/min(process$Median, na.rm = TRUE)
process <- process[order(Median)]
plot_vox <- function(dt, title) {
par(mar = c(2,2,2,0))
x <- barplot(dt$Median, names.arg = dt$language, main = title, yaxt = "n",
col = co, ylim = c(0,ceiling(max(dt$Median, na.rm = TRUE))), border = F)
axis(2, seq(0,ceiling(max(dt$Median, na.rm = TRUE))), las = 1)
text(x, dt$Median + 0.1, labels = format(round(dt$Median,2), nsmall = 2))
if (is.na(dt$Median[length(dt$Median)])) text(x[length(x)], 1.5, "Matlab \n cannot \n read \n compressed \n files", srt=0)
}
# Plotting both running times
loading <- R[operation %in% c("read_uncompressed", "read_compressed"), c("language", "operation", "Median")]
loading$Median <- loading$Median/min(loading$Median, na.rm = TRUE)
loading <- loading[order(Median, language)]
loading
loading <- loading[order(Median, language, Median)]
loading <- loading[order(Median, language, Median)]
loading
loading <- loading[order(language, Median)]
loading
loading <- loading[order(Median, language)]
loading
loading <- loading[order(language, Median)]
loading
desired_order <- sample(levels(loading$language))
desired_order
type(desired_order[1])
class(desired_order[1])
desired_order <- c("R", "Julia", "Python", "Matlab")
desired_order <- c("R", "Python", "Julia", "Matlab")
?reorder
as.factor(loading$language)
loading$language <- as.factor(loading$language)
reorder(loading$language, reorder(R, Python, Julia, Matlab))
reorder(loading$language, reorder("R", "Python", "Julia", "Matlab"))
levels(loading$language)
desired_order
# Plotting both running times
loading <- R[operation %in% c("read_uncompressed", "read_compressed"), c("language", "operation", "Median")]
loading$Median <- loading$Median/min(loading$Median, na.rm = TRUE)
loading$language <- as.factor(loading$language)
desired_order <- c("R", "Python", "Julia", "Matlab")
loading$language <- factor(as.character(loading$language), levels = desired_order)
loading
loading <- loading[order(language, Median)]
loading
library(svglite)
library(data.table)
library(RColorBrewer)
co <- brewer.pal(7, "Set1")[2]
co2 <- brewer.pal(7, "Set1")[1]
data <- fread("../speed/x.csv")
R <- data[,list(min(time), mean(time), median(time),
max(time)), keyby = list(language, operation)]
cols <-  c("Min", "Mean", "Median", "Max")
colnames(R)[3:6] <- cols
R <- R[,(cols) := round(.SD,1), .SDcols=cols]
extra_row <- data.frame("Matlab", "read_compressed", NA, NA, NA, NA)
names(extra_row) <- names(R)
R <- rbind(R, extra_row)
R[order(operation, Median)]
compressed <- R[operation == "read_compressed", c("language", "Median")]
compressed$Median <- compressed$Median/min(compressed$Median, na.rm = TRUE)
compressed <- compressed[order(Median)]
uncompressed <- R[operation == "read_uncompressed", c("language", "Median")]
uncompressed$Median <- uncompressed$Median/min(uncompressed$Median, na.rm = TRUE)
uncompressed <- uncompressed[order(Median)]
process <- R[operation == "process", c("language", "Median")]
process$Median <- process$Median/min(process$Median, na.rm = TRUE)
process <- process[order(Median)]
plot_vox <- function(dt, title) {
par(mar = c(2,2,2,0))
x <- barplot(dt$Median, names.arg = dt$language, main = title, yaxt = "n",
col = co, ylim = c(0,ceiling(max(dt$Median, na.rm = TRUE))), border = F)
axis(2, seq(0,ceiling(max(dt$Median, na.rm = TRUE))), las = 1)
text(x, dt$Median + 0.1, labels = format(round(dt$Median,2), nsmall = 2))
if (is.na(dt$Median[length(dt$Median)])) text(x[length(x)], 1.5, "Matlab \n cannot \n read \n compressed \n files", srt=0)
}
# Plotting both running times
loading <- R[operation %in% c("read_uncompressed", "read_compressed"), c("language", "operation", "Median")]
loading$Median <- loading$Median/min(loading$Median, na.rm = TRUE)
loading$language <- as.factor(loading$language)
desired_order <- c("R", "Python", "Julia", "Matlab")
loading$language <- factor(as.character(loading$language), levels = desired_order)
loading <- loading[order(language, Median)]
plot_two <- function(){
par(mar = c(2,2,2,0))
cols <- ifelse(loading$operation == "read_compressed", co, co2)
x <- barplot(loading$Median, main = "Loading time relative to fastest", yaxt = "n",
col = cols, ylim = c(0,ceiling(max(loading$Median, na.rm = TRUE))), border = F)
posit <- rep(NA,4)
for(i in seq(1,4)){
posit[i] <- mean(c(x[(i*2)-1], x[i*2]))
}
axis(1, posit, labels = unique(loading$language), tick = 0)
axis(2, seq(0,ceiling(max(loading$Median, na.rm = TRUE))), las = 1)
text(x, loading$Median + 0.1, labels = format(round(loading$Median,2), nsmall = 2))
legend("topleft", col = c(co2, co), legend = c("Uncompressed", "Compressed"),
pch = 15, bty = "n")
if (is.na(loading$Median[length(loading$Median)])) text(x[length(x)], 2, "Matlab \n cannot \n read \n compressed \n files", srt=0)
}
plot_two()
# Parameters size
wid = 500
hei = 350
# Saving small png
png("png_small/uncompressed.png", width = wid, height = hei,
units = "px", pointsize = 14)
plot_vox(uncompressed, "Loading time relative to fastest - Uncompressed")
dev.off()
png("png_small/compressed.png", width = wid, height = hei,
units = "px", pointsize = 14)
plot_vox(compressed, "Loading time relative to fastest - Compressed")
dev.off()
png("png_small/processing.png", width = wid, height = hei,
units = "px", pointsize = 14)
plot_vox(process, paste("Annual mean and sd by year and firm", "\n", "Processing time relative to fastest"))
dev.off()
png("png_small/reading_time.png", width = wid, height = hei,
units = "px", pointsize = 14)
plot_two()
dev.off()
# Large png
png("png_large/uncompressed.png", width = wid*2, height = hei*2,
units = "px", pointsize = 20)
plot_vox(uncompressed, "Loading time relative to fastest - Uncompressed")
dev.off()
png("png_large/compressed.png", width = wid*2, height = hei*2,
units = "px", pointsize = 20)
plot_vox(compressed, "Loading time relative to fastest - Compressed")
dev.off()
png("png_large/processing.png", width = wid*2, height = hei*2,
units = "px", pointsize = 20)
plot_vox(process, paste("Annual mean and sd by year and firm", "\n", "Relative processing time"))
dev.off()
png("png_large/reading_time.png", width = wid*2, height = hei*2,
units = "px", pointsize = 20)
plot_two()
dev.off()
# Svg
svglite("svg/uncompressed.svg")
plot_vox(uncompressed, "Loading time relative to fastest - Uncompressed")
dev.off()
svglite("svg/compressed.svg")
plot_vox(compressed, "Loading time relative to fastest - Compressed")
dev.off()
svglite("svg/processing.svg")
plot_vox(process, paste("Annual mean and sd by year and firm", "\n", "Relative processing time"))
dev.off()
svglite("svg/reading_time.svg")
plot_two()
dev.off()
